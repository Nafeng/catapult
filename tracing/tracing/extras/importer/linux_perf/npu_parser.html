<!DOCTYPE html>
<!--
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/extras/importer/linux_perf/parser.html">
<link rel="import" href="/tracing/model/counter.html">

<script>
'use strict';

/**
 * @fileoverview Parses scheduler events in the Linux event trace format.
 */
tr.exportTo('tr.e.importer.linux_perf', function() {
  const Parser = tr.e.importer.linux_perf.Parser;

  /**
   * Parses npu trace events.
   * @constructor
   */
  function NpuParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('vpp',
        NpuParser.prototype.onVpp.bind(this));
    importer.registerEventHandler('npu',
        NpuParser.prototype.onJpuOrNpu.bind(this));
    importer.registerEventHandler('jpu',
        NpuParser.prototype.onJpuOrNpu.bind(this));
    importer.registerEventHandler('vpu',
        NpuParser.prototype.onVpu.bind(this));
  }

  const TestExports = {};

  const vppTaskName = {
    s: 'split',
    c: 'crop',
    r: 'resize',
  }
  NpuParser.prototype = {
    __proto__: Parser.prototype,

    onVpp(eventName, cpuNumber, pid, ts, eventBase) {
      if (eventBase.details.length < 2) return false;
      const npu = this.importer.model.kernel[eventName];
      const task = vppTaskName[eventBase.details.charAt(1)];
      npu.switch(ts, eventBase.details.charAt(0)
        , `${eventBase.threadName}:${task.toUpperCase()}`, { task });
    },

    onJpuOrNpu(eventName, cpuNumber, pid, ts, eventBase) {
      if (eventBase.details.length < 1) return false;
      const npu = this.importer.model.kernel[eventName];
      npu.switch(ts, eventBase.details.charAt(0), eventBase.threadName, { pid });
    },

    onVpu(eventName, cpuNumber, pid, ts, eventBase) {
      if (eventBase.details.length === 0) return false;
      const kernel = this.importer.model.kernel;
      let value = parseInt(eventBase.details.substring(1));
      const vpuCounter = kernel[eventName].getOrCreateCounter('', 'vpu');
      if (vpuCounter.numSeries === 0) {
        vpuCounter.addSeries(new tr.model.CounterSeries('vpu',
            tr.b.ColorScheme.getColorIdForGeneralPurposeString('vpu')));
      }
      vpuCounter.series.forEach(function(series) {
        if (series.name === 'vpu') {
          series.addCounterSample(ts, value);
        }
      });
    },

    /**
     * Parses npu events.
     */
    onEvent(eventName, cpuNumber, pid, ts, eventBase) {
      const event = npuRE.exec(eventBase.details);
      console.log(event)
      if (!event) return false;
      const [ , action, task, value ] = event;

      const kernel = this.importer.model.kernel;
      if (eventName === 'vpu') {
        const vpuCounter = kernel['vpu'].getOrCreateCounter('', 'vpu');
        if (vpuCounter.numSeries === 0) {
          vpuCounter.addSeries(new tr.model.CounterSeries('vpu',
              tr.b.ColorScheme.getColorIdForGeneralPurposeString(
                  vpuCounter.name + '.' + 'vpu')));
        }
        vpuCounter.series.forEach(function(series) {
          if (series.name === 'vpu') {
            series.addCounterSample(ts, value);
          }
        });
      } else {
        const npu = kernel[eventName];
        npu.switch(ts, action, eventBase.threadName, { task });
      }

      return true;
    },

  };

  Parser.register(NpuParser);

  return {
    NpuParser,
    _NpuParserTestExports: TestExports
  };
});
</script>
